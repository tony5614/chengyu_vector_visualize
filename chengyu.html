<!DOCTYPE html><html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>成語向量</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.18.2/dist/index.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans TC', 'Microsoft JhengHei', sans-serif;
      font-weight: 300;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
    }
    #logContainer {
      margin-top: 20px;
      text-align: left;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    #logToggle {
      margin-bottom: 5px;
      cursor: pointer;
      color: #007bff;
      text-decoration: underline;
      font-size: 14px;
    }
    #log {
      white-space: pre-line;
      font-size: 14px;
      color: #333;
      display: none;
    }
    #mainContainer {
      display: flex;
      flex-direction: row; /* 左右排列 inputContainer 與 rightContainer */
      gap: 20px;
      align-items: flex-start;
    }

    #inputContainer {
      display: flex;
      flex-direction: column; /* 讓按鈕、label、textarea 垂直排列 */
      gap: 10px;
    }

    #rightContainer {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }
  </style>
</head>
<body>
  <h1>成語向量視覺化</h1>
  <div id="mainContainer">
    <div id="inputContainer">
      <label>
        <input type="checkbox" id="showAxisLabels" checked>
        顯示座標軸標籤
      </label>
      <button onclick="generateVector()">產生向量</button>
      <textarea id="idiomInput" placeholder="每行輸入一個四字成語" rows="20" cols="10">舉一反三</textarea>
      <div id="chainListContainer">
        <h3>接龍鍊列表</h3>
        <div id="chainList" style="max-height: 300px; overflow-y: auto; font-size: 14px; text-align: left;"></div>
      </div>
    </div>

    <div id="rightContainer">
      <div id="canvasContainer"></div>
      <div id="logContainer">
        <div id="logToggle" onclick="toggleLog()">顯示除錯資訊</div>
        <div id="log"></div>
      </div>
    </div>
  </div>
  <script>
    const shengmuMap = "_,b,p,m,f,d,t,n,l,g,k,h,j,q,x,zh,ch,sh,r,z,c,s,y,w".split(',');
    const yunmuMap = [
      "a", "o", "e", "i", "u", "ü",
      "ai", "ei", "ui", "ao", "ou", "iu",
      "ie", "üe", "er", "an", "en", "in", "un", "ün",
      "ang", "eng", "ing", "ong",
      "ia", "ua", "uo", "uai", "iao", "ian", "uan", "iang", "uang", "iong",
      "ue" // 確保包含 ue
    ];
    let vectors = [];
    let idiomLabels = [];
    let pinyinPairs = [];
    let hoveredChain = [];
    let idioms = [];
    let lastLoggedChain = ""; // 新增在 global 區域
    let lastHoveredIndex = -1;   
    let allChains = [];
    let selectedChainIndex = -1;
    let prevHoveredIndex = -1;
    
    function mouseMoved() {
      if (mouseX < 0 || mouseY < 0 || mouseX > width || mouseY > height) return;

      const currentHovered = getHoveredIndex();
      if (currentHovered !== prevHoveredIndex) {
        hoveredIndex = currentHovered;
        hoveredChain = getChainFromIndex(hoveredIndex);
        redraw();
        prevHoveredIndex = currentHovered;
      }
    }
    
    
    function getHoveredIndex() {
      for (let i = 0; i < vectors.length; i++) {
        const [x1, y1, x2, y2] = vectors[i];
        if (isHoveredOverLine(x1, y1, x2, y2)) {
          return i;
        }
      }
      return -1;
    }
    function buildAllChains() {
      allChains = [];
      const visited = new Set();

      function dfs(index, path) {
        const currentLast = pinyinPairs[index].last;
        let extended = false;
        for (let i = 0; i < pinyinPairs.length; i++) {
          if (!path.includes(i) && pinyinPairs[i].first === currentLast) {
            dfs(i, [...path, i]);
            extended = true;
          }
        }
        if (!extended) allChains.push(path);
      }

      for (let i = 0; i < pinyinPairs.length; i++) {
        dfs(i, [i]);
      }

      renderChainList();
    }
    
    function renderChainList() {
      const container = document.getElementById("chainList");
      container.innerHTML = "";

      allChains.forEach((chain, idx) => {
        const idiomStr = chain.map(i => idioms[i]).join(" → ");
        const item = document.createElement("div");
        item.textContent = idiomStr;
        item.style.cursor = "pointer";
        item.style.padding = "4px";
        item.style.borderBottom = "1px solid #ccc";

        if (idx === selectedChainIndex) {
          item.style.backgroundColor = "#eef";
        }

        item.onclick = () => {
          selectedChainIndex = idx;
          hoveredChain = chain;
          renderChainList();
        };
        container.appendChild(item);
      });
    }
    
    function windowResized() {
      const container = document.getElementById("canvasContainer");
      const newWidth = container.offsetWidth;
      const newHeight = windowHeight - 250;
      resizeCanvas(newWidth, newHeight);
    }
    function setup() {
      pixelDensity(1);
      const container = document.getElementById("canvasContainer");
      const initialWidth = container.offsetWidth;
      const initialHeight = windowHeight - 250;
      createCanvas(initialWidth, initialHeight).parent("canvasContainer");
      textAlign(CENTER);
      textFont('Noto Sans TC');
      textSize(10);
      noLoop();
    }
    function isHoveredOverLine(x1, y1, x2, y2, threshold = 5) {
      const px = mouseX;
      const py = mouseY;

      // 1. 距離起點
      const distStart = dist(px, py, x1, y1);
      if (distStart < threshold) return true;

      // 2. 距離終點
      const distEnd = dist(px, py, x2, y2);
      if (distEnd < threshold) return true;

      // 3. 距離線段
      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSq = dx * dx + dy * dy;
      if (lengthSq === 0) return dist(px, py, x1, y1) < threshold;

      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
      t = Math.max(0, Math.min(1, t));

      const closestX = x1 + t * dx;
      const closestY = y1 + t * dy;
      const distToLine = dist(px, py, closestX, closestY);
      return distToLine < threshold;
    }
    function draw() {
      background(245);
      stroke(180);
      strokeWeight(1);
      let showLabels = document.getElementById("showAxisLabels").checked;

      line(50, height - 50, width - 50, height - 50);
      textAlign(CENTER);
      stroke(180);
      fill(0);
      for (let i = 0; i < shengmuMap.length; i++) {
        let x = map(i, 0, shengmuMap.length - 1, 50, width - 50);
        line(x, height - 55, x, height - 45);
        if (showLabels) text(shengmuMap[i], x, height - 30);
        if (showLabels) {
          textSize(8);
          text(x.toFixed(0), x, height - 15);
        }
      }

      line(50, 50, 50, height - 50);
      textAlign(RIGHT);
      let topMargin = 50;
      let bottomMargin = height - 50;
      let totalHeight = bottomMargin - topMargin;
      let stepY = totalHeight / (yunmuMap.length - 1);

      for (let j = 0; j < yunmuMap.length; j++) {
        let y = bottomMargin - j * stepY;
        line(45, y, 55, y);
        if (showLabels) text(yunmuMap[j], 40, y + 3);
        if (showLabels) {
          textSize(8);
          text(y.toFixed(0), 25, y + 3);
        }
      }



      if (selectedChainIndex !== -1 && allChains[selectedChainIndex]) {
        hoveredChain = allChains[selectedChainIndex];
      } else {
        hoveredChain = [];
        for (let i = 0; i < vectors.length; i++) {
          const [x1, y1, x2, y2] = vectors[i];
          const idiom = idioms[i];
          const hovered = isHoveredOverLine(x1, y1, x2, y2);

          if (hovered) {
            if (i !== lastHoveredIndex) {
              console.log(`滑鼠座標：(${mouseX.toFixed(1)}, ${mouseY.toFixed(1)})`);
              console.log(`線段 ${i}（${idiom}）：(${x1.toFixed(1)}, ${y1.toFixed(1)}) → (${x2.toFixed(1)}, ${y2.toFixed(1)}), hovered=${hovered}`);
              console.log("觸發接龍鍊來自線段：", i, "成語：", idiom);
              lastHoveredIndex = i;
            }
            hoveredChain = getChainFromIndex(i);
            break;
          }
        }
      }



      //先畫出 isHovered = false
      for (let i = 0; i < vectors.length; i++) {
        const [x1, y1, x2, y2] = vectors[i];
        const [first, last] = idiomLabels[i];
        const isHovered = hoveredChain.includes(i);
        if(isHovered == true)
        {
          continue;
        }
        else
        {        
          stroke(isHovered ? 'red' : 0);
          fill(isHovered ? 'red' : 200);
          strokeWeight(1);
          stroke(isHovered ? 'red' : 200,isHovered ? 'red' : 200,isHovered ? 'red' : 200 , isHovered ? 'red' : 200); // 藍色 + 透明度（0~255，數字越小越淡）
          line(x1, y1, x2, y2);

          let angle = atan2(y2 - y1, x2 - x1);
          push();
          translate(x2, y2);
          rotate(angle);
          noStroke();
          triangle(0, 0, -8, 4, -8, -4);
          pop();

          stroke(isHovered ? 'red' : 200);
          fill(isHovered ? 'red' : 200);
          ellipse(x1, y1, 4, 4);
          ellipse(x2, y2, 4, 4);

          textSize(12);
          textAlign(CENTER);
          fill(isHovered ? 'red' : 200);
          
          text(first, x1, y1 - 10); // 提高一點，讓座標不重疊
          text(last, x2, y2 - 10);

          textSize(10);

          text(`(${Math.round(x1)}, ${Math.round(y1)})`, x1, y1 + 12);
          text(`(${Math.round(x2)}, ${Math.round(y2)})`, x2, y2 + 12);
        }
      }


      //再畫 isHovered = true, 才可以蓋在上面
      for (let i = 0; i < vectors.length; i++) {
        const [x1, y1, x2, y2] = vectors[i];
        const [first, last] = idiomLabels[i];
        const isHovered = hoveredChain.includes(i);
        if(isHovered == true)
        {          
          stroke(isHovered ? 'red' : 0);
          fill(isHovered ? 'red' : 200);
          strokeWeight(1);
          stroke(isHovered ? 'red' : 200,isHovered ? 'red' : 200,isHovered ? 'red' : 200 , isHovered ? 'red' : 200); // 藍色 + 透明度（0~255，數字越小越淡）
          line(x1, y1, x2, y2);

          let angle = atan2(y2 - y1, x2 - x1);
          push();
          translate(x2, y2);
          rotate(angle);
          noStroke();
          triangle(0, 0, -8, 4, -8, -4);
          pop();

          stroke(isHovered ? 'red' : 200);
          fill(isHovered ? 'red' : 200);
          ellipse(x1, y1, 4, 4);
          ellipse(x2, y2, 4, 4);

          textSize(18);
          textAlign(CENTER);
          fill(isHovered ? 'red' : 200);
          
          text(first, x1, y1 - 10); // 提高一點，讓座標不重疊
          text(last, x2, y2 - 10);

          textSize(10);

          text(`(${Math.round(x1)}, ${Math.round(y1)})`, x1, y1 + 12);
          text(`(${Math.round(x2)}, ${Math.round(y2)})`, x2, y2 + 12);
        }
        else
        {
          continue;
        }
      }


      if (hoveredChain.length > 0) {
        const chainIdioms = hoveredChain.map(index => idioms[index]).join(" → ");
        if (chainIdioms !== lastLoggedChain) {
          console.log("接龍鍊：", chainIdioms);
          lastLoggedChain = chainIdioms;
        }
      } else {
        lastLoggedChain = ""; // 如果沒有 hover 到，清空記錄
      }
    }




function getChainFromIndex(index) {
  let longestChain = [];

  function dfs(currentIdx, path, visited) {
    const node = pinyinPairs[currentIdx];
    if (!node) return; // 防止 index 對應不到節點
  
    visited.add(currentIdx);
    path.push(currentIdx);

    const currentLast = pinyinPairs[currentIdx].last;
    let extended = false;

    for (let i = 0; i < idioms.length; i++) {
      if (visited.has(i)) continue;
      if (pinyinPairs[i].first === currentLast) {
        dfs(i, [...path], new Set(visited));  // 拷貝 path 與 visited 傳下去
        extended = true;
      }
    }

    if (!extended && path.length > longestChain.length) {
      longestChain = path;
    }
  }

  dfs(index, [], new Set());
  return longestChain;
}
    
    
    
    function generateVector() {
      const logDiv = document.getElementById("log");
      const idiomLines = document.getElementById("idiomInput").value.trim().split('\n').map(s => s.trim()).filter(s => s.length === 4);
      if (idiomLines.length === 0) {
        alert("請輸入至少一個四字成語（每行一個）");
        return;
      }

      vectors = [];
      idiomLabels = [];
      pinyinPairs = [];
      idioms = [];
      let debugMsg = "";

      idiomLines.forEach(idiom => {
        const first = idiom[0];
        const last = idiom[3];
        const firstPinyin = pinyinPro.pinyin(first, { toneType: 'num' });
        const lastPinyin = pinyinPro.pinyin(last, { toneType: 'num' });

        const parsePinyin = (p) => {
          const match = p.match(/^([bpmfdtnlgkhjqxrzcsyw]{1,2})?([a-züv]+)(\d)$/i);
          if (!match) {
            console.log("無法解析拼音：", p);
            return null;
          }

          let shengmu = match[1] ? match[1].toLowerCase() : "_";
          let yunmu = match[2].replace('v', 'ü').toLowerCase();
          if (yunmu === 'ue') yunmu = 'ü' + 'e';
          let tone = parseInt(match[3]);

          return { shengmu, yunmu, tone };
        };

        const f = parsePinyin(firstPinyin);
        const l = parsePinyin(lastPinyin);
        if (!f || !l) return;

        const getIndex = (arr, val) => arr.indexOf(val) === -1 ? 0 : arr.indexOf(val);
        const fIndex = getIndex(shengmuMap, f.shengmu);
        const lIndex = getIndex(shengmuMap, l.shengmu);
        const fX = map(fIndex, 0, shengmuMap.length - 1, 50, width - 50);
        const lX = map(lIndex, 0, shengmuMap.length - 1, 50, width - 50);

        const topMargin = 50;
        const bottomMargin = height - 50;
        const totalHeight = bottomMargin - topMargin;
        const stepY = totalHeight / (yunmuMap.length - 1);
        const fY = bottomMargin - getIndex(yunmuMap, f.yunmu) * stepY;
        const lY = bottomMargin - getIndex(yunmuMap, l.yunmu) * stepY;

        idioms.push(idiom);
        vectors.push([fX, fY, lX, lY]);
        idiomLabels.push([first, last]);
        pinyinPairs.push({ first: firstPinyin, last: lastPinyin });

        debugMsg += `成語：${idiom}\n首字：${first} → ${firstPinyin}（${f.shengmu}, ${f.yunmu}, ${f.tone}）\n尾字：${last} → ${lastPinyin}（${l.shengmu}, ${l.yunmu}, ${l.tone}）\n\n`;
      });

      logDiv.innerText = debugMsg;
      
      redraw();
      buildAllChains(); // 產生所有接龍鏈
    }

    function toggleLog() {
      const log = document.getElementById("log");
      const toggle = document.getElementById("logToggle");
      log.style.display = log.style.display === "none" ? "block" : "none";
      toggle.innerText = log.style.display === "none" ? "顯示除錯資訊" : "隱藏除錯資訊";
    }
  </script>
</body>
</html>
