<!DOCTYPE html><html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>成語向量視覺化</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.18.2/dist/index.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans TC', 'Microsoft JhengHei', sans-serif;
      font-weight: 300;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
    }
    #logContainer {
      margin-top: 20px;
      text-align: left;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    #logToggle {
      margin-bottom: 5px;
      cursor: pointer;
      color: #007bff;
      text-decoration: underline;
      font-size: 14px;
    }
    #log {
      white-space: pre-line;
      font-size: 14px;
      color: #333;
      display: none;
    }
  </style>
</head>
<body>
  <h1>成語向量視覺化</h1>
  <textarea id="idiomInput" placeholder="每行輸入一個四字成語" rows="4" cols="30">舉一反三</textarea>
  <button onclick="generateVector()">產生向量</button>
  <label>
    <input type="checkbox" id="showAxisLabels" checked>
    顯示座標軸標籤
  </label>
  <div id="canvasContainer"></div>
  <div id="logContainer">
    <div id="logToggle" onclick="toggleLog()">顯示除錯資訊</div>
    <div id="log"></div>
  </div>
  <script>
    const shengmuMap = "b,p,m,f,d,t,n,l,g,k,h,j,q,x,zh,ch,sh,r,z,c,s,y,w".split(',');
    const yunmuMap = [
      "a", "o", "e", "i", "u", "ü",
      "ai", "ei", "ui", "ao", "ou", "iu",
      "ie", "üe", "er", "an", "en", "in", "un", "ün",
      "ang", "eng", "ing", "ong",
      "ia", "ua", "uo", "uai", "iao", "ian", "uan", "iang", "uang", "iong",
      "ue" // 確保包含 ue
    ];let vectors = [];
    let idiomLabels = [];
    let pinyinPairs = [];
    let hoveredChain = [];
    let idioms = [];
    let lastLoggedChain = ""; // 新增在 global 區域

    function setup() {
      pixelDensity(2);
      createCanvas(400, 400).parent("canvasContainer");
      textAlign(CENTER);
      textFont('Noto Sans TC');
      textSize(10);
    }
    function isHoveredOverLine(x1, y1, x2, y2, threshold = 10) {
      const midX = (x1 + x2) / 2;
      const midY = (y1 + y2) / 2;
      return dist(mouseX, mouseY, midX, midY) < threshold;
    }
    function draw() {
      background(245);
      stroke(180);
      strokeWeight(1);
      let showLabels = document.getElementById("showAxisLabels").checked;

      line(50, height - 50, width - 50, height - 50);
      textAlign(CENTER);
      stroke(180);
      fill(0);
      for (let i = 0; i < shengmuMap.length; i++) {
        let x = map(i, 0, shengmuMap.length - 1, 50, width - 50);
        line(x, height - 55, x, height - 45);
        if (showLabels) text(shengmuMap[i], x, height - 30);
      }

      line(50, 50, 50, height - 50);
      textAlign(RIGHT);
      let topMargin = 50;
      let bottomMargin = height - 50;
      let totalHeight = bottomMargin - topMargin;
      let stepY = totalHeight / (yunmuMap.length - 1);

      for (let j = 0; j < yunmuMap.length; j++) {
        let y = bottomMargin - j * stepY;
        line(45, y, 55, y);
        if (showLabels) text(yunmuMap[j], 40, y + 3);
      }

      hoveredChain = [];
      for (let i = 0; i < vectors.length; i++) {
        const [x1, y1, x2, y2] = vectors[i];
        if (isHoveredOverLine(x1, y1, x2, y2)) {
          hoveredChain = getChainFromIndex(i);
          break;
        }
      }

      for (let i = 0; i < vectors.length; i++) {
        const [x1, y1, x2, y2] = vectors[i];
        const [first, last] = idiomLabels[i];
        const isHovered = hoveredChain.includes(i);

        stroke(isHovered ? 'red' : 0);
        fill(isHovered ? 'red' : 50);
        strokeWeight(1);
        line(x1, y1, x2, y2);

        let angle = atan2(y2 - y1, x2 - x1);
        push();
        translate(x2, y2);
        rotate(angle);
        noStroke();
        triangle(0, 0, -8, 4, -8, -4);
        pop();

        stroke(isHovered ? 'red' : 0);
        fill(isHovered ? 'red' : 50);
        ellipse(x1, y1, 4, 4);
        ellipse(x2, y2, 4, 4);

        textSize(12);
        textAlign(CENTER);
        text(first, x1, y1 - 10);
        text(last, x2, y2 - 10);
      }

      if (hoveredChain.length > 0) {
        const chainIdioms = hoveredChain.map(index => idioms[index]).join(" → ");
        if (chainIdioms !== lastLoggedChain) {
          console.log("接龍鍊：", chainIdioms);
          lastLoggedChain = chainIdioms;
        }
      } else {
        lastLoggedChain = ""; // 如果沒有 hover 到，清空記錄
      }
    }

    function getChainFromIndex(index) {
      const chain = [];
      const visited = new Set();
      let queue = [index];

      while (queue.length) {
        let current = queue.shift();
        if (visited.has(current)) continue;
        visited.add(current);
        chain.push(current);

        const currentLast = pinyinPairs[current].last;
        for (let i = 0; i < pinyinPairs.length; i++) {
          if (!visited.has(i) && pinyinPairs[i].first === currentLast) {
            queue.push(i);
          }
        }
      }
      return chain;
    }

    function generateVector() {
      const logDiv = document.getElementById("log");
      const idiomLines = document.getElementById("idiomInput").value.trim().split('\n').map(s => s.trim()).filter(s => s.length === 4);
      if (idiomLines.length === 0) {
        alert("請輸入至少一個四字成語（每行一個）");
        return;
      }

      vectors = [];
      idiomLabels = [];
      pinyinPairs = [];
      idioms = [];
      let debugMsg = "";

      idiomLines.forEach(idiom => {
        const first = idiom[0];
        const last = idiom[3];
        const firstPinyin = pinyinPro.pinyin(first, { toneType: 'num' });
        const lastPinyin = pinyinPro.pinyin(last, { toneType: 'num' });

        const parsePinyin = (p) => {
          const match = p.match(/^([bpmfdtnlgkhjqxrzcsyw]{1,2}?)([a-züv]+)(\d)$/i);
          if (!match) {
            console.log("無法解析拼音：", p);
            return null;
          }

          let shengmu = match[1] || '_';
          let yunmu = match[2].replace('v', 'ü');
          if (yunmu === 'ue') yunmu = 'ü' + 'e';
          let tone = parseInt(match[3]);

          return { shengmu, yunmu, tone };
        };

        idioms.push(idiom);
        const f = parsePinyin(firstPinyin);
        const l = parsePinyin(lastPinyin);
        if (!f || !l) return;

        const getIndex = (arr, val) => arr.indexOf(val) === -1 ? 0 : arr.indexOf(val);
        const fIndex = getIndex(shengmuMap, f.shengmu);
        const lIndex = getIndex(shengmuMap, l.shengmu);
        const fX = map(fIndex, 0, shengmuMap.length - 1, 50, width - 50);
        const lX = map(lIndex, 0, shengmuMap.length - 1, 50, width - 50);

        const topMargin = 50;
        const bottomMargin = height - 50;
        const totalHeight = bottomMargin - topMargin;
        const stepY = totalHeight / (yunmuMap.length - 1);
        const fY = bottomMargin - getIndex(yunmuMap, f.yunmu) * stepY;
        const lY = bottomMargin - getIndex(yunmuMap, l.yunmu) * stepY;

        vectors.push([fX, fY, lX, lY]);
        idiomLabels.push([first, last]);
        pinyinPairs.push({ first: firstPinyin, last: lastPinyin });

        debugMsg += `成語：${idiom}\n首字：${first} → ${firstPinyin}（${f.shengmu}, ${f.yunmu}, ${f.tone}）\n尾字：${last} → ${lastPinyin}（${l.shengmu}, ${l.yunmu}, ${l.tone}）\n\n`;
      });

      logDiv.innerText = debugMsg;
    }

    function toggleLog() {
      const log = document.getElementById("log");
      const toggle = document.getElementById("logToggle");
      log.style.display = log.style.display === "none" ? "block" : "none";
      toggle.innerText = log.style.display === "none" ? "顯示除錯資訊" : "隱藏除錯資訊";
    }
  </script>
</body>
</html>
