<!DOCTYPE html><html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>成語向量</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.18.2/dist/index.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans TC', 'Microsoft JhengHei', sans-serif;
      font-weight: 300;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
    }
    #log {
      white-space: pre-line;
      font-size: 14px;
      color: #333;
    }
    #mainContainer {
      display: flex;
      flex-direction: row; /* 左右排列 inputContainer 與 rightContainer */
      gap: 20px;
      align-items: flex-start;
    }

    #inputContainer {
      display: flex;
      flex-direction: column; /* 讓按鈕、label、textarea 垂直排列 */
      gap: 10px;
    }

    #rightContainer {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }
  </style>
</head>
<body>
  <h1>成語向量視覺化</h1>
  <div id="mainContainer">
    <div id="inputContainer">
      <label>
        <input type="checkbox" id="showAxisLabels" checked>
        顯示座標軸標籤
      </label>
      <button onclick="generateVector()">產生向量</button>
      <textarea id="idiomInput" placeholder="每行輸入一個四字成語" rows="20" cols="10">
一葉知秋
一擲千金
動輒得咎
海枯石爛
不假思索
不動聲色
神機妙算
輕諾寡信
冠冕堂皇
大同小異
大言不慚
大謬不然
生花妙筆
趨炎附勢
翻雲覆雨
擢髮難數
不合時宜
不得要領
一錢不值
藕斷絲連
心驚肉跳
天真爛漫
囊空如洗
螳螂捕蟬
予取予求
高瞻遠矚
三顧茅廬
龍飛鳳舞
心直口快
盤根錯節
權宜之計
耀武揚威
平心靜氣
以身作則
史無前例
殫精竭慮
衣冠楚楚
光風霽月
少不更事
回頭是岸
回心轉意
獨當一面
興師問罪
目不交睫
寥若晨星
針鋒相對
吉人天相
安貧樂道
安居樂業
不識抬舉
餘音繞梁
輕描淡寫
彈丸之地
自欺欺人
有始無終
刎頸之交
改頭換面
意氣用事
路不拾遺
群龍無首
妙手空空
求全責備
滔滔不絕
逐臭之夫
道聽塗說
楚楚可憐
無濟於事
忠心耿耿
陽春白雪
絡繹不絕
合浦珠還
信手拈來
順手牽羊
無獨有偶
盛氣凌人
爭先恐後
發人深省
朋比為奸
惴惴不安
隨心所欲
惜墨如金
若無其事
苦盡甘來
津津有味
花天酒地
席不暇暖
奄奄一息
玩世不恭
街談巷議
顧名思義
馬耳東風
歡欣鼓舞
面紅耳赤
閉月羞花
欲速不達
前事不忘，後事之師
懲前毖後
五日京兆
無可奈何
改弦更張
少見多怪
知難而退
始作俑者
撥亂反正
醉翁之意不在酒
精衛填海
實事求是
聞一知十
倚馬可待
多難興邦
為人作嫁
風燭殘年
要言不煩
米珠薪桂
自以為是
豺狼當道
談何容易
問道於盲
英雄無用武之地
城下之盟
弄璋之喜
如虎添翼
叱吒風雲
一朝一夕
格殺勿論
一場春夢
借題發揮
英雄氣短
神出鬼沒
高風亮節
眉開眼笑
寅吃卯糧
涓滴歸公
根深蒂固
烽火連天
望而卻步
一念之差
同室操戈
率由舊章
明眸皓齒
獨木難支
不時之需
赤地千里
貪贓枉法
逍遙法外
長驅直入
見仁見智
博古通今
欺世盜名
惱羞成怒
椎心泣血
驚濤駭浪
鞭辟入裡
一團和氣
傷天害理
明鏡高懸
高山流水
花團錦簇
不二法門
無懈可擊
大書特書
亡命之徒
兔死狐悲
感激涕零
赤手空拳
拍案叫絕
別有天地
遇人不淑
暗度陳倉
耳目一新
當務之急
福至心靈
衣冠禽獸
死心塌地
新陳代謝
搖旗吶喊
搖搖欲墜
有教無類
有名無實
槁木死灰
有目共睹
慘不忍睹
小巧玲瓏
憐香惜玉
耳鬢廝磨
寡不敵眾
語無倫次
寥寥無幾
目瞪口呆
生殺予奪
摩頂放踵
珠聯璧合
未卜先知
火樹銀花
半推半就
平地風波
調虎離山
瞠乎其後
天馬行空
烏煙瘴氣
參差不齊
噬臍莫及
賠了夫人又折兵
天誅地滅
天羅地網
龍蟠虎踞
切膚之痛
手忙腳亂
聳人聽聞
一五一十
氣宇軒昂
隱惡揚善
軒然大波
出口成章
雞皮鶴髮
人去樓空
三頭六臂
出水芙蓉
觸景生情
黃袍加身
三寸不爛之舌
捨本逐末
一心一意
韋編三絕
一了百了
腰纏萬貫
額手稱慶
一無所有
文不對題
心驚膽戰
水性楊花
心煩意亂
文不加點
以貌取人
寸步不離
大聲疾呼
不置可否
打退堂鼓
四通八達
無妄之災
甘之如飴
不約而同
名韁利鎖
付之一笑
一心一計
因時制宜
不識之無
支吾其詞
禍不單行
現身說法
設身處地
光天化日
一手障天
鐘鳴鼎食
鐵石心腸
安身立命
安然無恙
廬山真面目
深思熟慮
平分秋色
躍躍欲試
自強不息
掩人耳目
耳熟能詳
自食其力
老驥伏櫪
行雲流水
安分守己
瞠目結舌
忍無可忍
捷足先登
李代桃僵
隱姓埋名
輾轉反側
冷嘲熱諷
張口結舌
安如泰山
百聞不如一見
魂飛魄散
細水長流
養尊處優
難能可貴
脫胎換骨
奮不顧身
身敗名裂
潛移默化
隻手遮天
輕而易舉
漠不關心
笑逐顏開
牛衣對泣
舞文弄墨
披肝瀝膽
事與願違
暢所欲言
目不見睫
兩面三刀
拋頭露面
雨後春筍
盡忠報國
金城湯池
戮力同心
枉費心機
三秋一日
以毒攻毒
目無全牛
金戈鐵馬
近水樓臺
四分五裂
壽比南山
美中不足
枯木逢春
腹背受敵
過猶不及
咬牙切齒
威風凜凜
身無長物
裝模作樣
裝腔作勢
愁眉苦臉
枵腹從公
入室操戈
趁火打劫
勢均力敵
相知恨晚
貽笑大方
無能為力
方寸已亂
殺人如麻
日三秋
一毫不拔
風平浪靜
子虛烏有
通宵達旦
氣急敗壞
雪上加霜
尸位素餐
循序漸進
野心勃勃
無法無天
人言可畏
好高騖遠
孺子可教
將信將疑
一傅眾咻
微乎其微
蓬頭垢面
草草了事
洞天福地
揚長而去
不辨菽麥
得魚忘筌
綱舉目張
鷸蚌相爭
鑄成大錯
瞭如指掌
與虎謀皮
尋章摘句
堅壁清野
應聲蟲
曾參殺人
倒屣相迎
堂堂正正
盡善盡美
貉一丘
眾望所歸
肅然起敬
鴻鵠之志
坦腹東床
鳥盡弓藏
揭竿而起
逼上梁山
一邱貉
下里巴人
一目瞭然
不謀而合
反覆無常
方枘圓鑿
秋風過耳
氣象萬千
哀鴻遍野
一覽了然
師心自用
簞食壺漿
駭人聽聞
燕雀處堂
結草銜環
疾風勁草
偃武修文
一目即了
甚囂塵上
捉襟見肘
超群絕倫
良藥苦口
忘年之交
自出機杼
防患未然
十行俱下
網開一面
相濡以沫
五行俱下
五行並下
老嫗能解
木人石心
坐懷不亂
一目數行
朝令夕改
一目五行
欲罷不能
破天荒
十行一目
教學相長
向壁虛造
酒池肉林
七行俱下
目下十行
數行並下
一字百金
一帆順風
一成不易
反脣相稽
百戰百勝
藍田生玉
剖腹藏珠
以卵投石
衣帶一江
魯魚亥豕
一箭雙鵰
慘綠少年
殷鑒不遠
衣帶水
決一雌雄
決雌雄
一面如舊
摩肩接踵
以管窺天
片言九鼎
一語九鼎
野人獻曝
夢筆生花
九鼎一言
一言難罄
百事無成
一事未成
戶限為穿
白頭偕老
萬事無成
不成一事
沉魚落雁
事事無成
千金一刻
耳邊風
知己知彼
一呼再諾
一呼百喏
露出馬腳
屋下架屋
一念之誤
一念之錯
背水一戰
一念差池
山木自寇
一板三眼
三眼一板
尺幅千里
一筆三過
一刀見血
大敗塗地
壹敗塗地
一貧似水
清貧如洗
一齊眾楚
一齊眾咻
暫勞永逸
嘆為觀止
一勞久逸
春夢一場
行屍走肉
一揮而成
負重致遠
渾無所有
登徒子
明珠暗投
了無所有
休戚與共
一介不苟
助紂為虐
一毫不苟
一視之仁
孤行一意
直搗黃龍
千丈一落
葉落知秋
落葉知秋
一堂和氣
纖塵不染
一塵不受
一塵不到
一塵不涉
不染一塵
防意如城
一網無遺
一口道破
驚人一鳴
一曝十寒
十寒一暴
雙鵰一箭
雙雕一箭
千金一諾
季布一諾
百金一諾
千金諾
不值一錢
反求諸己
一文不值
一無所知
不值一文
半文不值
一錢不直
夢寐以求
玩火自焚
不直一文
不值半文
分文不直
分毫不直
不直一錢
黃鐘毀棄
一舉兩便
一舉兩利
一舉兩全
千金一擲
一揮千金
一隙不通
不通一竅
見景生情
一跌不振
踣不復振
移天易日
跌而不振
莫展一籌
半籌不納
一籌不吐
一籌不畫
半籌不展
觸而即發
有觸即發
七上八落
七嘴八張
七張八嘴
東道主
樂而忘返
七孔生煙
七竅煙生
七竅煙騰
牛之一毛
萬死一生
十死一生
折衝尊俎
十生九死
九死餘生
九層雲外
九霄雲路
如山如海
人海人山
人眾勝天
人強勝天
人謀敓天造
桃花人面
獸心人面
人浮於食
食浮於人
同流合汙
勢不可當
入不支出
入石三分
操戈入室
八拜至交
八拜定交
玲瓏八面
八窗玲瓏
力不從願
力不副心
力不逮心
力不及心
力爭上流
筆力透背
十全之美
十家九空
十成九穩
十拿十穩
三人市虎
三夫成虎
三寸之舌
三寸舌
三申五令
舞文弄法
五令三申
遊刃有餘
三言兩句
三言五語
一長兩短
三長四短
兩短三長
一長半短
一長二短
四德三從
九流三教
三緘口
三頭八臂</textarea>
      <div id="chainListContainer">
        <h3>接龍鍊列表</h3>
        <div id="chainList" style="max-height: 300px; overflow-y: auto; font-size: 14px; text-align: left;"></div>
      </div>
    </div>

    <div id="rightContainer">
      <div id="canvasContainer"></div>
      <div id="logContainer">
        <div id="log"></div>
      </div>
    </div>
  </div>
  <script>
    const shengmuMap = "_,b,p,m,f,d,t,n,l,g,k,h,j,q,x,zh,ch,sh,r,z,c,s,y,w".split(',');
    const yunmuMap = [
      "a", "o", "e", "i", "u", "ü",
      "ai", "ei", "ui", "ao", "ou", "iu",
      "ie", "üe", "er", "an", "en", "in", "un", "ün",
      "ang", "eng", "ing", "ong",
      "ia", "ua", "uo", "uai", "iao", "ian", "uan", "iang", "uang", "iong",
      "ue" // 確保包含 ue
    ];
    let vectors = [];
    let idiomLabels = [];
    let pinyinPairs = [];
    let hoveredChain = [];
    let idioms = [];
    let lastLoggedChain = ""; // 新增在 global 區域
    let chainIdioms = "";
    let lastHoveredIndex = -1;   
    let allChains = [];
    let selectedChainIndex = -1;
    let prevHoveredIndex = -1;
    let needsRedraw = true;
    
    function mouseMoved() {
      if (mouseX < 0 || mouseY < 0 || mouseX > width || mouseY > height) return;

      const currentHovered = getHoveredIndex();
      if (currentHovered !== prevHoveredIndex) {
        hoveredIndex = currentHovered;
        hoveredChain = getChainFromIndex(hoveredIndex);
        needsRedraw = true;

        prevHoveredIndex = currentHovered;
      }
    }
    
    
    function getHoveredIndex() {
      for (let i = 0; i < vectors.length; i++) {
        const [x1, y1, x2, y2] = vectors[i];
        if (isHoveredOverLine(x1, y1, x2, y2)) {
          return i;
        }
      }
      return -1;
    }
    function buildAllChains() {
      allChains = [];
      const visited = new Set();

      function dfs(index, path) {
        const currentLast = pinyinPairs[index].last;
        let extended = false;
        for (let i = 0; i < pinyinPairs.length; i++) {
          if (!path.includes(i) && pinyinPairs[i].first === currentLast) {
            dfs(i, [...path, i]);
            extended = true;
          }
        }
        if (!extended) allChains.push(path);
      }

      for (let i = 0; i < pinyinPairs.length; i++) {
        dfs(i, [i]);
      }

      renderChainList();
    }
    
    function renderChainList() {
      const container = document.getElementById("chainList");
      container.innerHTML = "";

      allChains.forEach((chain, idx) => {
        const idiomStr = chain.map(i => idioms[i]).join(" → ");
        const item = document.createElement("div");
        item.textContent = idiomStr;
        item.style.cursor = "pointer";
        item.style.padding = "4px";
        item.style.borderBottom = "1px solid #ccc";

        if (idx === selectedChainIndex) {
          item.style.backgroundColor = "#eef";
        }

        item.onclick = () => {
          selectedChainIndex = idx;
          hoveredChain = chain;
          renderChainList();
        };
        container.appendChild(item);
      });
    }
    
    function windowResized() {
      const container = document.getElementById("canvasContainer");
      const newWidth = container.offsetWidth;
      const newHeight = windowHeight - 250;
      resizeCanvas(newWidth, newHeight);
    }
    function setup() {
      pixelDensity(1);
      const container = document.getElementById("canvasContainer");
      const initialWidth = container.offsetWidth;
      const initialHeight = windowHeight - 250;
      createCanvas(initialWidth, initialHeight).parent("canvasContainer");
      textAlign(CENTER);
      textFont('Noto Sans TC');
      textSize(10);

    }
    function isHoveredOverLine(x1, y1, x2, y2, threshold = 5) {
      const px = mouseX;
      const py = mouseY;

      // 1. 距離起點
      const distStart = dist(px, py, x1, y1);
      if (distStart < threshold) return true;

      // 2. 距離終點
      const distEnd = dist(px, py, x2, y2);
      if (distEnd < threshold) return true;

      // 3. 距離線段
      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSq = dx * dx + dy * dy;
      if (lengthSq === 0) return dist(px, py, x1, y1) < threshold;

      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
      t = Math.max(0, Math.min(1, t));

      const closestX = x1 + t * dx;
      const closestY = y1 + t * dy;
      const distToLine = dist(px, py, closestX, closestY);
      return distToLine < threshold;
    }
    function draw() {
      if(needsRedraw) {
        needsRedraw = false;
        background(245);
        stroke(180);
        strokeWeight(1);
        let showLabels = document.getElementById("showAxisLabels").checked;

        line(50, height - 50, width - 50, height - 50);
        textAlign(CENTER);
        stroke(180);
        fill(0);
        for (let i = 0; i < shengmuMap.length; i++) {
          let x = map(i, 0, shengmuMap.length - 1, 50, width - 50);
          line(x, height - 55, x, height - 45);
          if (showLabels) text(shengmuMap[i], x, height - 30);
          if (showLabels) {
            textSize(8);
            text(x.toFixed(0), x, height - 15);
          }
        }

        line(50, 50, 50, height - 50);
        textAlign(RIGHT);
        let topMargin = 50;
        let bottomMargin = height - 50;
        let totalHeight = bottomMargin - topMargin;
        let stepY = totalHeight / (yunmuMap.length - 1);

        for (let j = 0; j < yunmuMap.length; j++) {
          let y = bottomMargin - j * stepY;
          line(45, y, 55, y);
          if (showLabels) text(yunmuMap[j], 40, y + 3);
          if (showLabels) {
            textSize(8);
            text(y.toFixed(0), 25, y + 3);
          }
        }



        if (selectedChainIndex !== -1 && allChains[selectedChainIndex]) {
          hoveredChain = allChains[selectedChainIndex];
        } else {
          hoveredChain = [];
          for (let i = 0; i < vectors.length; i++) {
            const [x1, y1, x2, y2] = vectors[i];
            const idiom = idioms[i];
            const hovered = isHoveredOverLine(x1, y1, x2, y2);

            if (hovered) {
              if (i !== lastHoveredIndex) {
                //console.log(`滑鼠座標：(${mouseX.toFixed(1)}, ${mouseY.toFixed(1)})`);
                //console.log(`線段 ${i}（${idiom}）：(${x1.toFixed(1)}, ${y1.toFixed(1)}) → (${x2.toFixed(1)}, ${y2.toFixed(1)}), hovered=${hovered}`);
                //console.log("觸發接龍鍊來自線段：", i, "成語：", idiom);
                lastHoveredIndex = i;
              }
              hoveredChain = getChainFromIndex(i);
              break;
            }
          }
        }



        //先畫出 isHovered = false
        for (let i = 0; i < vectors.length; i++) {
          const [x1, y1, x2, y2] = vectors[i];
          const [first, last] = idiomLabels[i];
          const isHovered = hoveredChain.includes(i);
          if(isHovered == true)
          {
            continue;
          }
          else
          {        
            stroke(isHovered ? 'red' : 0);
            fill(isHovered ? 'red' : 200);
            strokeWeight(1);
            stroke(isHovered ? 'red' : 200,isHovered ? 'red' : 200,isHovered ? 'red' : 200 , isHovered ? 'red' : 200); // 藍色 + 透明度（0~255，數字越小越淡）
            line(x1, y1, x2, y2);

            let angle = atan2(y2 - y1, x2 - x1);
            push();
            translate(x2, y2);
            rotate(angle);
            noStroke();
            triangle(0, 0, -8, 4, -8, -4);
            pop();

            stroke(isHovered ? 'red' : 200);
            fill(isHovered ? 'red' : 200);
            ellipse(x1, y1, 4, 4);
            ellipse(x2, y2, 4, 4);

            textSize(12);
            textAlign(CENTER);
            fill(isHovered ? 'red' : 200);
            
            text(first, x1, y1 - 10); // 提高一點，讓座標不重疊
            text(last, x2, y2 - 10);

            textSize(10);

            text(`(${Math.round(x1)}, ${Math.round(y1)})`, x1, y1 + 12);
            text(`(${Math.round(x2)}, ${Math.round(y2)})`, x2, y2 + 12);
          }
        }


        //再畫 isHovered = true, 才可以蓋在上面
        for (let i = 0; i < vectors.length; i++) {
          const [x1, y1, x2, y2] = vectors[i];
          const [first, last] = idiomLabels[i];
          const isHovered = hoveredChain.includes(i);
          if(isHovered == true)
          {          
            stroke(isHovered ? 'red' : 0);
            fill(isHovered ? 'red' : 200);
            strokeWeight(1);
            stroke(isHovered ? 'red' : 200,isHovered ? 'red' : 200,isHovered ? 'red' : 200 , isHovered ? 'red' : 200); // 藍色 + 透明度（0~255，數字越小越淡）
            line(x1, y1, x2, y2);

            let angle = atan2(y2 - y1, x2 - x1);
            push();
            translate(x2, y2);
            rotate(angle);
            noStroke();
            triangle(0, 0, -8, 4, -8, -4);
            pop();

            stroke(isHovered ? 'red' : 200);
            fill(isHovered ? 'red' : 200);
            ellipse(x1, y1, 4, 4);
            ellipse(x2, y2, 4, 4);

            textSize(18);
            textAlign(CENTER);
            fill(isHovered ? 'red' : 200);
            
            text(first, x1, y1 - 10); // 提高一點，讓座標不重疊
            text(last, x2, y2 - 10);

            textSize(10);

            text(`(${Math.round(x1)}, ${Math.round(y1)})`, x1, y1 + 12);
            text(`(${Math.round(x2)}, ${Math.round(y2)})`, x2, y2 + 12);
            
            
          }
          else
          {
            continue;
          }
        }


        if (hoveredChain.length > 0) {
          chainIdioms = hoveredChain.map(index => idioms[index]).join(" → ");
          if (chainIdioms !== lastLoggedChain) {          
            const logDiv = document.getElementById("log");
            logDiv.innerHTML = `<pre>\n===== 接龍路徑 =====\n${chainIdioms}\n</pre>`;
            lastLoggedChain = chainIdioms;
          }
        } else {
          lastLoggedChain = ""; // 如果沒有 hover 到，清空記錄
        }
      }  
    }




function getChainFromIndex(index) {
  let longestChain = [];

  function dfs(currentIdx, path, visited) {
    const node = pinyinPairs[currentIdx];
    if (!node) return; // 防止 index 對應不到節點
  
    visited.add(currentIdx);
    path.push(currentIdx);

    const currentLast = pinyinPairs[currentIdx].last;
    let extended = false;

    for (let i = 0; i < idioms.length; i++) {
      if (visited.has(i)) continue;
      if (pinyinPairs[i].first === currentLast) {
        dfs(i, [...path], new Set(visited));  // 拷貝 path 與 visited 傳下去
        extended = true;
      }
    }

    if (!extended && path.length > longestChain.length) {
      longestChain = path;
    }
  }

  dfs(index, [], new Set());
  return longestChain;
}
    
    
    
    function generateVector() {
      const logDiv = document.getElementById("log");
      const idiomLines = document.getElementById("idiomInput").value.trim().split('\n').map(s => s.trim()).filter(s => s.length === 4);
      if (idiomLines.length === 0) {
        alert("請輸入至少一個四字成語（每行一個）");
        return;
      }

      vectors = [];
      idiomLabels = [];
      pinyinPairs = [];
      idioms = [];
      //let debugMsg = "";

      idiomLines.forEach(idiom => {
        const first = idiom[0];
        const last = idiom[3];
        const firstPinyin = pinyinPro.pinyin(first, { toneType: 'num' });
        const lastPinyin = pinyinPro.pinyin(last, { toneType: 'num' });

        const parsePinyin = (p) => {
          const match = p.match(/^([bpmfdtnlgkhjqxrzcsyw]{1,2})?([a-züv]+)(\d)$/i);
          if (!match) {
            console.log("無法解析拼音：", p);
            return null;
          }

          let shengmu = match[1] ? match[1].toLowerCase() : "_";
          let yunmu = match[2].replace('v', 'ü').toLowerCase();
          if (yunmu === 'ue') yunmu = 'ü' + 'e';
          let tone = parseInt(match[3]);

          return { shengmu, yunmu, tone };
        };

        const f = parsePinyin(firstPinyin);
        const l = parsePinyin(lastPinyin);
        if (!f || !l) return;

        const getIndex = (arr, val) => arr.indexOf(val) === -1 ? 0 : arr.indexOf(val);
        const fIndex = getIndex(shengmuMap, f.shengmu);
        const lIndex = getIndex(shengmuMap, l.shengmu);
        const fX = map(fIndex, 0, shengmuMap.length - 1, 50, width - 50);
        const lX = map(lIndex, 0, shengmuMap.length - 1, 50, width - 50);

        const topMargin = 50;
        const bottomMargin = height - 50;
        const totalHeight = bottomMargin - topMargin;
        const stepY = totalHeight / (yunmuMap.length - 1);
        const fY = bottomMargin - getIndex(yunmuMap, f.yunmu) * stepY;
        const lY = bottomMargin - getIndex(yunmuMap, l.yunmu) * stepY;

        idioms.push(idiom);
        vectors.push([fX, fY, lX, lY]);
        idiomLabels.push([first, last]);
        pinyinPairs.push({ first: firstPinyin, last: lastPinyin });

        //debugMsg += `成語：${idiom}\n首字：${first} → ${firstPinyin}（${f.shengmu}, ${f.yunmu}, ${f.tone}）\n尾字：${last} → ${lastPinyin}（${l.shengmu}, ${l.yunmu}, ${l.tone}）\n\n`;
      });

      //logDiv.innerText = debugMsg;
      
      redraw();
      buildAllChains(); // 產生所有接龍鏈
    }


  </script>
</body>
</html>
